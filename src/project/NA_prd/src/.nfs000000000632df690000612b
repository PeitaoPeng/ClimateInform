#!/bin/sh

set -eaux

#=========================================================
# test various techniques in empr hcst of NA t&p with pls_eof 
#=========================================================
lcdir=/cpc/home/wd52pp/project/NA_prd/src
tmp=/cpc/consistency/tmp
if [ ! -d $tmp ] ; then
  mkdir -p $tmp
fi

datadir1=/cpc/consistency/NA_prd/obs
datadir2=/cpc/consistency/NA_prd/skill
#
cd $tmp
# 
model=pls
#
for var1 in hadoisst; do
for var2 in prec; do

for nmod_pls in 7; do
#
var1_tp=3mon  # or 3mon
var2_tp=3mon  # or mon
#
nmod_v2=5  #var2 eof mode
#
var1_lag=3 # monthly: =1; 3mon: =3
#
nlead=1
byear=1949
nyro=71  #obs period 1950->2020
nts=52   #training start
nyrv=`expr $nyro - $nts`  # verification period long ??-2020
#
imx=360
jmx=180
idx=1;idy=1
ngrd=77  # w.coast
#ngrd=36  # Cal prec
#
#for tgtss in jfm fma mam amj mjj jja jas aso son ond ndj djf; do
 for tgtss in djf; do

if [ $tgtss == jfm ]; then itgtbgn=13; ssn=1; fi
if [ $tgtss == fma ]; then itgtbgn=14; ssn=2; fi
if [ $tgtss == mam ]; then itgtbgn=15; ssn=3; fi
if [ $tgtss == amj ]; then itgtbgn=16; ssn=4; fi
if [ $tgtss == mjj ]; then itgtbgn=17; ssn=5; fi
if [ $tgtss == jja ]; then itgtbgn=18; ssn=6; fi
if [ $tgtss == jas ]; then itgtbgn=19; ssn=7; fi
if [ $tgtss == aso ]; then itgtbgn=20; ssn=8; fi
if [ $tgtss == son ]; then itgtbgn=21; ssn=9; fi
if [ $tgtss == ond ]; then itgtbgn=22; ssn=10; fi
if [ $tgtss == ndj ]; then itgtbgn=23; ssn=11; fi
if [ $tgtss == djf ]; then itgtbgn=24; ssn=12; fi

ld=1
while  [ $ld -le $nlead ]
do

/bin/rm fort.*
#
# correction for dynamic model fcst
#
cat > parm.h << EOF
       parameter(nt=$nyro)
       parameter(nts=$nts)
       parameter(ntv=$nyrv)
c
       parameter(imx=$imx,jmx=$jmx)
c
       parameter(isv1=1,iev1=360,jsv1=70,jev1=110)
c      parameter(isv1=1,iev1=360,jsv1=70,jev1=160)
 
c      parameter(isv2=234,iev2=240,jsv2=124,jev2=138)
       parameter(isv2=234,iev2=240,jsv2=123,jev2=131)
c
       parameter(nmod=$nmod_v2,modpls=$nmod_pls)
       parameter(ngrd=$ngrd)
       parameter(ld=$ld)
       parameter(id_eof=0)
       parameter(ID=1)
       parameter(undef=-9.99E+8)
       parameter(itgtbgn=$itgtbgn)
EOF
#
cat > pls.f << EOF
      program input_data
      include "parm.h"
      dimension w2d(imx,jmx),w2d2(imx,jmx),w2d3(imx,jmx)
      dimension wic(imx,jmx),avv1(imx,jmx)
      dimension w3dv1(imx,jmx,nt),w3dv2(imx,jmx,nt)
      dimension prd(imx,jmx,ntv)

      dimension ts1(nt),ts2(nt)
      dimension tso(ntv),ts3(ntv),ts4(ntv)
      dimension ts5(modpls),kts(modpls)
 
      dimension xlat(jmx),coslat(jmx),cosr(jmx)
c
      real corv2(imx,jmx,nmod),regv2(imx,jmx,nmod)
      real rpcv2(nmod,nt)
      real rpcf(nmod,ntv),rpcf2(nmod,modpls,ntv),rpcf3(nmod,ntv)
      real corm(imx,jmx),rmsm(imx,jmx)
      real corp(imx,jmx),rmsp(imx,jmx)
c
      real*4 pc(nt,modpls),pat(imx,jmx,modpls),pat2(imx,jmx,modpls)
      real*4 var(modpls),pco(modpls)
      real*4 corn(modpls),rmsn(modpls)
c
      real mpick(nmod)
      data mpick /1,4,1,3,4/ ! conus with t&extp sst
c
      open(unit=10,form='unformatted',access='direct',recl=4*imx*jmx)
      open(unit=20,form='unformatted',access='direct',recl=4*imx*jmx)

      open(unit=30,form='unformatted',access='direct',recl=4*imx*jmx)
      open(unit=40,form='unformatted',access='direct',recl=4*ntv)
      open(unit=50,form='unformatted',access='direct',recl=4*imx*jmx)
c
      open(unit=51,form='unformatted',access='direct',recl=4*imx*jmx)
      open(unit=52,form='unformatted',access='direct',recl=4*ntv)
      open(unit=53,form='unformatted',access='direct',recl=4*imx*jmx)

      open(unit=60,form='formatted')
c*************************************************
C
C== have coslat
C
      do j=1,jmx
        xlat(j)=-89.5+(j-1)*1.
        coslat(j)=cos(xlat(j)*3.14159/180)  !for EOF use
        cosr(j)=sqrt(coslat(j))  !for EOF use
      enddo
C
C read obs & model data

      ir1=itgtbgn-ld-$var1_lag
      ir2=itgtbgn
      do it=1,nt

        read(10,rec=ir1) w2d
        read(20,rec=ir2) w2d2
        do i=1,imx
        do j=1,jmx
           w3dv1(i,j,it)=w2d(i,j)
           w3dv2(i,j,it)=w2d2(i,j)
        enddo
        enddo

       ir1=ir1+12
       ir2=ir2+12
      enddo !it loop

c
      call setzero_3d(prd,imx,jmx,ntv)

      itp=0
      DO mt=nts,nt-1

      mtp=mt+1
      itp=itp+1

      print *, 'mt=',mt
c
C eof for var2
c
      call eof_s(w3dv2,cosr,nt,mt,ngrd,nmod,undef,
     &imx,jmx,$idx,$idy,isv2,iev2,jsv2,jev2,rpcv2,corv2,regv2,id_eof)
c
c forecast rpc for mtp 
c
      DO m=1,nmod

        do it=1,mt
        ts1(it)=rpcv2(m,it)
        enddo
        
      call anom(ts1,nt,mt,av)

      do i=1,imx
      do j=1,jmx
        wic(i,j)=w3dv1(i,j,mtp)
      enddo
      enddo
c
      call pls_tmarch(nt,mt,imx,jmx,isv1,iev1,jsv1,jev1,modpls,
     &ts1,w3dv1,wic,pc,pco,pat,pat2,var,coslat,undef,ID)
c
c compose rpcf for mtp
c
        rpcf(m,itp)=0
        mpls=mpick(m)
c       do n=1,modpls
        do n=1,mpls
          rpcf(m,itp)=rpcf(m,itp)+pco(n)
        enddo

        do n=1,modpls
          rpcf2(m,n,itp)=0
          do k=1,n
          rpcf2(m,n,itp)=rpcf2(m,n,itp)+pco(k)
          enddo
        enddo

      enddo ! m loop
c
c forecasted var2 on grids
      do i=1,imx
      do j=1,jmx

      if(abs(w3dv2(i,j,1)).lt.999) then

        do n=1,nmod
          prd(i,j,itp)=prd(i,j,itp)+rpcf(n,itp)*regv2(i,j,n)
        enddo
      else
          prd(i,j,itp)=undef
      endif

      enddo
      enddo
c
c
      ENDDO  ! mt loop
c
c write out eof, coef, pcprd over it=1->nt 
      IF(ld.eq.1) then
      iw=0
      iw2=0
      call setzero_2d(rpcf3,nmod,ntv)

      DO m=1,nmod
c var2 eof pattern
        do i=1,imx
        do j=1,jmx
          w2d(i,j)=regv2(i,j,m)
        enddo
        enddo
        write(51,rec=m) w2d

c obs rpc and rpcf
        do it=1,ntv
          it1=nts+it
          ts3(it)=rpcv2(m,it1)
          ts4(it)=rpcf(m,it)
        enddo
          iw=iw+1
          write(52,rec=iw) ts3
          iw=iw+1
          write(52,rec=iw) ts4

c cor(rpcf,rpcv2)over plsm_sum 1->mod_pls
      do n=1,modpls
         do it=1,ntv
          it1=nts+it
           ts3(it)=rpcv2(m,it1)
           ts4(it)=rpcf2(m,n,it)
         enddo
      call acrms_t(ts3,ts4,corn(n),rmsn(n),ntv)

      write(6,*) 'eofm=',m, ' plsn=',n,'cor&rms=',corn(n),rmsn(n)

      enddo ! n loop
c
c select optimal rpcf
      do n=1,modpls 
        kts(n)=n
      enddo
c
      call hpsort(modpls,modpls,corn,kts)
c
      if(corn(modpls).gt.0.1) then
        do it=1,ntv
        rpcf3(m,it)=rpcf2(m,kts(modpls),it)
        enddo
      endif
      print *, 'corn=',corn
      print *, 'kts=',kts
        
c rcoef_vs_var1 cor & regr pattern
        do it=1,nt
          ts1(it)=rpcv2(m,it)
        enddo

        do j=1,jmx
        do i=1,imx
        if(abs(w3dv1(i,j,1)).lt.999) then

        do it=1,nt
          ts2(it)=w3dv1(i,j,it)
        enddo

        call regr_t(ts1,ts2,nt,nt,w2d(i,j),w2d2(i,j))
        else

        w2d(i,j)=undef
        w2d2(i,j)=undef

        endif
        enddo
        enddo
          iw2=iw2+1
          write(53,rec=iw2) w2d
          iw2=iw2+1
          write(53,rec=iw2) w2d2
      ENDDO ! loop m
c
c     print *, 'rpcf3(it=nt)='
c     print *, rpcf3(1,nt),rpcf3(2,nt),rpcf3(3,nt),rpcf3(4,nt)
c     print *, rpcf3(5,nt),rpcf3(6,nt),rpcf3(7,nt),rpcf3(8,nt)
c     print *, rpcf3(9,nt),rpcf3(10,nt)
c     print *, 'rpcf3(it=8)='
c     print *, rpcf3(1,8),rpcf3(2,8),rpcf3(3,8),rpcf3(4,8)
c     print *, rpcf3(5,8),rpcf3(6,8),rpcf3(7,8),rpcf3(8,8)
c     print *, rpcf3(9,8),rpcf3(10,8)
c
c test hcst var2 on grids
      do it=1,ntv
      do i=1,imx
      do j=1,jmx

      if(abs(w3dv2(i,j,1)).lt.999) then
        do m=1,nmod
c         prd(i,j,it)=prd(i,j,it)+rpcf3(m,it)*regv2(i,j,m)
        enddo
      else
c         prd(i,j,it)=undef
      endif

      enddo
      enddo
      enddo ! it loop

      ENDIF
c
C skill calculation
      do i=1,imx
      do j=1,jmx
      if(abs(w3dv2(i,j,1)).lt.999) then
        do it=1,ntv
          it1=it+nts
          tso(it)=w3dv2(i,j,it1)
          ts3(it)=prd(i,j,it)
        enddo
        call acrms_t(ts3,tso,corp(i,j),rmsp(i,j),ntv)
      else
        corp(i,j)=undef
        rmsp(i,j)=undef
      endif
      enddo
      enddo

      iw=1
      write(30,rec=iw) corp
      iw=iw+1 
      write(30,rec=iw) rmsp
c
      call avg_2d(corp,imx,jmx,isv2,iev2,jsv2,jev2,coslat,avgp)
c     call avg_2d(corp,360,180,221,300,115,135,coslat,avgp)
      print *, 'avg corp =', avgp
c
C spatial corr skill
      print *, 'sp cor start'
      do it=1,ntv
        it1=nts+it
        do i=1,imx
        do j=1,jmx
            w2d2(i,j)=w3dv2(i,j,it1)
            w2d3(i,j)=prd(i,j,it)
        enddo
        enddo
        call cor_sp(w2d2,w2d3,imx,jmx,isv2,iev2,
     &jsv2,jev2,coslat,ts3(it))
      enddo

      write(40,rec=1) ts3
c
C write out obs and pls_prd
      iw=0
      do it=1,ntv
        it1=nts+it
        do i=1,imx
        do j=1,jmx
          w2d2(i,j)=w3dv2(i,j,it1)
          w2d3(i,j)=prd(i,j,it)
        enddo
        enddo
        iw=iw+1
        write(50,rec=iw) w2d2
        iw=iw+1
        write(50,rec=iw) w2d3
      enddo

      STOP
      END
c
      subroutine eof_s(fin,cosr,ntot,nt,ng,nmod,undef,
     &im,jm,idx,idy,is,ie,js,je,rpc,cor,reg,id)
c
      dimension fin(im,jm,ntot),cosr(jm)
      dimension aaa(ng,nt),wk(nt,ng)
      dimension weval(nt),wevec(ng,nt),wcoef(nt,nt)
      dimension reval(nmod),revec(ng,nmod)
      dimension rcoef(nmod,nt),rpc(nmod,ntot)
      dimension tt(nmod,nmod),rwk(ng),rwk2(ng,nmod)

      dimension ts1(nt),ts2(nt)
      dimension cor(im,jm,nmod),reg(im,jm,nmod)
c
C select grid data
      do it=1,nt
      ig=0
      do i=is,ie,idx
      do j=js,je,idy
        if(fin(i,j,1).gt.-1000) then
        ig=ig+1
        aaa(ig,it)=cosr(j)*fin(i,j,it)
        endif
      enddo
      enddo
      print *, 'ngrd=',ig
      enddo
C EOF analysis
      call REOFS(aaa,ng,nt,nt,wk,id,weval,wevec,wcoef,
     &           nmod,reval,revec,rcoef,tt,rwk,rwk2)
C
C normalize rpc and have cor&reg patterns
      do m=1,nmod
        do it=1,nt
        ts1(it)=rcoef(m,it)
        enddo
        call normal_a(ts1,nt,nt)

        do it=1,nt
        rpc(m,it)=ts1(it)
        enddo
c
        do j=1,jm
        do i=1,im

        if(fin(i,j,1).gt.-1000) then

        do it=1,nt
        ts2(it)=fin(i,j,it)
        enddo

        call regr_t(ts1,ts2,nt,nt,cor(i,j,m),reg(i,j,m))

        else

        cor(i,j,m)=undef
        reg(i,j,m)=undef
        endif

        enddo
        enddo
      enddo  ! m loop

      return
      end

      subroutine avg_2d(f,im,jm,is,ie,js,je,cosl,av)
      dimension f(im,jm),cosl(jm)

      av=0
      w=0 
      do i=is,ie
      do j=js,je
        if(abs(f(i,j)).lt.1000.) then
          av=av+f(i,j)*cosl(j)
          w=w+cosl(j)
        endif
      enddo
      enddo
      av=av/w
c
      return
      end
c
      subroutine acrms_t(f,o,ac,rms,n)
      dimension f(n),o(n)

      oo=0.
      ff=0.
      of=0.
      rms=0
      do i=1,n
        oo=oo+o(i)*o(i)
        ff=ff+f(i)*f(i)
        of=of+f(i)*o(i)
        rms=rms+(f(i)-o(i))*(f(i)-o(i))
      enddo
      tt=float(n)
      stdo=sqrt(oo/tt)
      stdf=sqrt(ff/tt)
      of=of/tt
      ac=of/(stdo*stdf)
      rms=sqrt(rms/tt)
c
      return
      end

      SUBROUTINE setzero_2d(fld,n,m)
      real fld(n,m)
      do i=1,n
      do j=1,m
         fld(i,j)=0.0
      enddo
      enddo
      return
      end

      SUBROUTINE setzero_3d(fld,n,m,k)
      real fld(n,m,k)
      do i=1,n
      do j=1,m
      do l=1,k
         fld(i,j,l)=0.0
      enddo
      enddo
      enddo
      return
      end

      subroutine normal_a(x,n,m)
      dimension x(n)
      avg=0
      do i=1,m
        avg=avg+x(i)/float(m)
      enddo
      var=0
      do i=1,m
        var=var+(x(i)-avg)*(x(i)-avg)/float(m)
      enddo
      std=sqrt(var)
      do i=1,m
        x(i)=(x(i)-avg)/std
      enddo
      return
      end
C
      SUBROUTINE regr_t(f1,f2,nt,ltime,cor,reg)

      real f1(nt),f2(nt)

      cor=0.
      sd1=0.
      sd2=0.

      do it=1,ltime
         cor=cor+f1(it)*f2(it)/float(ltime)
         sd1=sd1+f1(it)*f1(it)/float(ltime)
         sd2=sd2+f2(it)*f2(it)/float(ltime)
      enddo

      sd1=sd1**0.5
      sd2=sd2**0.5
      reg=cor/(sd1)
      cor=cor/(sd1*sd2)

      return
      end
c
      SUBROUTINE cor_sp(f1,f2,im,jm,is,ie,js,je,cosl,cor)

      real cosl(jm),f1(im,jm),f2(im,jm)

      cor=0.
      sd1=0.
      sd2=0.
      w=0.
      do i=is,ie
      do j=js,je
         if(abs(f1(i,j)).lt.1000.and.abs(f2(i,j)).lt.1000) then
         w=w+cosl(j)
         cor=cor+f1(i,j)*f2(i,j)*cosl(j)
         sd1=sd1+f1(i,j)*f1(i,j)*cosl(j)
         sd2=sd2+f2(i,j)*f2(i,j)*cosl(j)
         endif
      enddo
      enddo

      sd1=sqrt(sd1)
      sd2=sqrt(sd2)
      cor=cor/(sd1*sd2)

      return
      end
c========================
      subroutine anom(ts,n,m,avg)
      dimension ts(n)
        av=0
        do i=1,m
          av=av+ts(i)
        end do
        avg=av/float(m)
        do i=1,m
          ts(i)=ts(i)-avg
        end do
      return
      end
ccccccccccccccccccccccc
      SUBROUTINE hpsort(n,n2,ra,rb)
      INTEGER n,n2
      REAL ra(n),rb(n)
      INTEGER i,ir,j,l
      REAL rra
      if (n2.lt.2) return
      l=n2/2+1
      ir=n2
10    continue
        if(l.gt.1)then
          l=l-1
          rra=ra(l)
          rrb=rb(l)
        else
          rra=ra(ir)
          rrb=rb(ir)
          ra(ir)=ra(1)
          rb(ir)=rb(1)
          ir=ir-1
          if(ir.eq.1)then
            ra(1)=rra
            rb(1)=rrb
            return
          endif
        endif
        i=l
        j=l+l
20      if(j.le.ir)then
          if(j.lt.ir)then
            if(ra(j).lt.ra(j+1))j=j+1
          endif
          if(rra.lt.ra(j))then
            ra(i)=ra(j)
            rb(i)=rb(j)
            i=j
            j=j+j
          else
            j=ir+1
          endif
        goto 20
        endif
        ra(i)=rra
        rb(i)=rrb
      goto 10
      END
cccccccccccccccccccccccccccccccccccc
EOF
#
cp $lcdir/reof.s.f reof.s.f
cp $lcdir/pls_tmarch.s.f  pls.s.f
#
 gfortran -o prd.x reof.s.f pls.s.f pls.f
 ln -s $datadir1/$var1.$var1_tp.${byear}-curr.1x1.gr fort.10
 ln -s $datadir1/$var2.${byear}_cur.$var2_tp.1x1.gr  fort.20
#
 ln -s acrms.$ld                           fort.30
 ln -s spcor.$ld                           fort.40
 ln -s prdmp.$ld                           fort.50

 ln -s eofv2.ld$ld.gr                      fort.51
 ln -s pcv2.ld$ld.gr                       fort.52
 
 ln -s ptnv1.ld$ld.gr                      fort.53

 ln -s pls_skill.${var1}_2_${var2}.$tgtss.ld$ld.txt fort.60
 
 prd.x
#\rm fort.*
#
ld=$(( ld+1 ))
done  # for ld

#cat skill together

mv acrms.1 tsk.1
mv spcor.1 ssk.1
mv prdmp.1 prd.1
ld=2
while  [ $ld -le $nlead ]
do
ldm=$((ld-1))

cat tsk.$ldm  acrms.$ld > tsk.$ld
cat ssk.$ldm  spcor.$ld > ssk.$ld
cat prd.$ldm  prdmp.$ld > prd.$ld

\rm tsk.$ldm
\rm ssk.$ldm
\rm prd.$ldm

ld=$(( ld+1 ))
done  # for ld
#
mv tsk.$nlead skt.$ssn.gr
mv ssk.$nlead sks.$ssn.gr
mv prd.$nlead plsprd.$ssn.gr

cat>skt.$ssn.ctl<<EOF
dset ^skt.$ssn.gr
undef -9.99e+8
*
TITLE model
*
XDEF $imx LINEAR     0.   1.
YDEF $jmx LINEAR   -89.5  1.
zdef 1 linear 1 1
tdef $nlead linear jan1980 1yr
vars  2
acc 0 99 acc of prd
rms 0 99 rms of prd
endvars
EOF

cat>sks.$ssn.ctl<<EOF
dset ^sks.$ssn.gr
undef -9.99e+8
*
TITLE model
*
XDEF $nyrv LINEAR    0.  1.
YDEF 1 LINEAR     -90.5  1.
zdef 1 linear 1 1
tdef $nlead linear jan1980 1yr
vars  1
cor 0 99 pattern
endvars
EOF

cat>pls.$ssn.ctl<<EOF
dset ^pls.$ssn.gr
undef -9.99e+8
*
TITLE model
*
XDEF $imx LINEAR    0.   1.
YDEF $jmx LINEAR  -89.5  1.
zdef 1 linear 1 1
tdef $nyrv linear jan1982 1yr
edef 7 names e1 e2 e3 e4 e5 e6 e7
vars 2
o 0 99 obs
c 0 99 corrected prd
endvars
EOF

cat>eofv2.ld1.ctl<<EOF
dset ^eofv2.ld1.gr
undef -9.99e+8
*
TITLE model
*
XDEF $imx LINEAR    0.   1.
YDEF $jmx LINEAR  -89.5  1.
zdef 1 linear 1 1
tdef $nmod_v2 linear jan1982 1yr
edef 1 names e1
vars 1
regr 0 99 obs
endvars
EOF

cat>pcv2.ld1.ctl<<EOF
dset ^pcv2.ld1.gr
undef -9.99e+8
*
TITLE model
*
XDEF $nyrv LINEAR    0.  1.
YDEF 1 LINEAR     -90.5  1.
zdef 1 linear 1 1
tdef $nmod_v2 linear jan1980 1yr
vars  2
o 0 99 obs
f 0 99 pls
endvars
EOF

cat>ptnv1.ld1.ctl<<EOF
dset ^ptnv1.ld1.gr
undef -9.99e+8
*
TITLE model
*
XDEF $imx LINEAR    0.5  1.
YDEF $jmx LINEAR  -89.5  1.
zdef 1 linear 1 1
tdef $nmod_v2 linear jan1982 1yr
edef 1 names e1
vars 2
corr 0 99 corr
regr 0 99 regr
endvars
EOF

done  # for tgtss
done  # for nmod_pls
done  # for var2
done  # for var1
