This directory contains the files

   README     - this file
   pop.f      - source code for the POP program
   scalars.i  - declarations of scalars (included from pop.f)
   arrays.i   - declarations of arrays (included from pop.f)
   pop        - sample UNIX script to start executable POP program 
				(named pop.x) like in UNIX commands, or optionally, 
				give a help message (Bourne shell).
   prec.f     - a small program to test the precision (singe or double)
                of your NAGLIB mathematical library.
   data.dbl   - File with double precision data to test correct
				compilation of the POP program (SUN workstation only!)
				IMPORTANT: This file must be transferred to your Sun
					   	   workstation in BINARY mode!
   data.asc   - ASCII version of the data from data.dbl. 
   test.job   - Unix shell script to test the POP program on a 
				Sun workstation
   output.ori - Original output of the POP analysis of the test data.
				This should be compared to the file "output.this" which
				is produced by "test.job".

  Transfer these files from the disc to the computer where you want to
install the POP  program, e.g. using  the "ftp" utility. Be careful to
use binary mode for data.dbl. On a Unix system,  you will also have to
set execute  permission for the files "pop"   and "test.job" after the
transfer.

Note again: The files data.dbl, test.job and output.ori are only useful
			if you want to install the POP program on a Sun workstation
  			in a double precision  version (i.e. your NAGLIB library is
  			compiled in double precision). Or alternatively:

There is also an ascii version of the data in file "data.asc". To read
them use the formats in the following read statements:

	  integer i1,i2,i3,i4
	  double precision x(1000)

 1    continue
      read(1,'(4I10)',end=2) i1,i2,i3,i4
      read(1,'(6(1X,E13.5))') (x(i),i=1,i4)
      goto 1

 2    continue


Note, that to use the ascii data with the POP program you have to convert 
them to unformatted
data (single or double precision, depending on the precision of you NAGLIB)
with the above program fragment. You should expect slight differences in the
output from "output.ori" because of the reduced precision of the ascii data.



  See the  POP Manual and below  for the installation of  the program.
Also,  have  a look   at the beginning  of  the  file "scalars.i"  for
parameters you may have to change for your installation.

  In particular if  you  don't  have the NAGLIB  mathematical  library
available  you will have to  write own interface  subroutines with the
names called  by the POP  program where  you insert your  own code  or
calls to a math library you have (POP Manual, Appendix 4).

  Note that in some NAGLIB implementations (I think higher than NAGLIB
Mark 13)   single precision subroutines end with    the letter "E" and
double precision   subroutines with   "F".  In older   implementations
subroutines always end in "F" regardless of the precision. If you want
to install  the  program  in the  single  precision  version  and  get
messages from  the  linker about unknown   external references to  NAG
subroutines, e.g. C06FAF,  then you may have to  edit the  source code
pop.f manually and change all calls to NAG subroutines by substituting
the last letter "F" of the subroutine to "E".

  You  have to  take  care of  the  floating point  precision on  your
machine. E.g. if  your NAGLIB library  on you machine is compiled with
double precision you have to use double precision for the POP program,
too.   If NAGLIB  is  compiled with  single precision you  have to use
single precision  in  the POP program.   Also,  the precision of  your
compiled version of the POP program must match  the precision you used
to  write  the   floating  point values    in your  data   files.  

  The distribution disc contains a small program which you may compile
to test which precision your installed NAGLIB uses.
E.g. on a Sun just do:	f77 -o prec.x prec.f -lnag
      or on a Cray do:  cf77 -o prec.x prec.f -lnag
and type "prec.x".

The program has been tested with
   - a single precision version on a CRAY-2S computer
   - a double precision version on a Sun Sparc workstation

  The  Fortran code is written  for  single precision.  To compile the
program in a single precision version use the following commands:

	- on a Sun workstation: 
			f77 -w -o pop.x pop.f -lnag

	- on a Cray:
			cf77 -o pop.x pop.f -lnag

  For computers where you don't have f77 or cf77 use the corresponding
Fortran compiler and link the NAGLIB library appropriately.

  On  a Sun  workstation  it  is easy  to  produce a  double precision
executable by using the "-r8 -i4" option of the f77 Fortran compiler:

			f77 -r8 -i4 -w -o pop.x pop.f -lnag

  The   option  "-r8" just converts   all  single precision reals into
double precision and also intrinsic functions accordingly. Since "-r8"
also changes INTEGER*4 to INTEGER*8 the option "-i4" is used to change
this back to  INTEGER*4 which  is the  default on 32-bit  machines and
which is  likely to be length  of the integers  you used to write your
data files (remember  from the manual: each  floating point  record in
the data file is preceded by an integer header record).

   The double  precision  installation on   a Sun workstation   may be
tested by using the   files "data.dbl", "test.job"and "output.ori"  on
the distribution  disc.    Just  produce the  executable    "pop.x" as
described above and  run the shell script  test.job. This produces the
output file output.this which  can be compared  to the original output
of this POP analysis output.ori.


  If you have to compile a double precision version but you don't have
the   convenience of these (or corresponding)   options to the Fortran
compiler you  will  have to  change  the appropriate REAL declarations
into DOUBLE PRECISION and also to adjust calls to intrinsic functions.




The description for one of the NAG routines is missing in the manual. So
here it is:

------------------------------------------------------------------------------

F04AEF - NAG FORTRAN ROUTINE SUMMARY
======

A. Purpose
==========

 //F04AEF//  calculates  the  accurate  solution  of  a  set  of real linear
 equations with multiple right hand sides by Crout's factorisation method.

B. Specification
================

       SUBROUTINE F04AEF(A,IA,B,IB,N,M,C,IC,
      1   		WKSPCE,AA,IAA,BB,IBB,IFAIL)
       INTEGER IA,IB,N,M,IC,IAA,IBB,IFAIL
       real A(IA,N),B(IB,M),C(IC,M),WKSPCE(N),
      1   		AA(IAA,N),BB(IBB,M)


C. Parameters
=============

  Given a set of linear equations AX=B, the routine first decomposes A using
  Crout's  factorisation  with  partial  pivoting,  PA=LU,  where  P  is   a
  permutation matrix, L is lower triangular and U is unit upper triangular.


 1: A - //real// array of DIMENSION (IA,p) where p.GE.N.

  Before entry, A must contain the elements of the real matrix.

  Unchanged on exit.


 2: IA - INTEGER.

  On  entry,  IA  must specify the first dimension of array A as declared in
  the calling (sub)program (IA.GE.N).

  Unchanged on exit.


 3: B - //real// array of DIMENSION (IB,q) where q.GE.M.

  Before entry, B must contain the elements of the M right hand sides stored
  in columns. (See Section 11).

  Unchanged on exit. The routine **must not** be called with the  same  name
  for parameters B, C and BB.


 4: IB - INTEGER.

  On  entry,  IB  must specify the first dimension of array B as declared in
  the calling (sub)program (IB.GE.N).

  Unchanged on exit.


 5: N - INTEGER.

  On entry, N must specify the order of matrix A.

  Unchanged on exit.


 6: M - INTEGER.

  On entry, M must specify the number of right hand sides.

  Unchanged on exit.


 7: C - //real// array of DIMENSION (IC,r) where r.GE.M.

  On successful exit, C contains the M solution vectors.


 8: IC - INTEGER.

  On entry, IC must specify the first dimension of array C  as  declared  in
  the calling (sub)program (IC.GE.N).

  Unchanged on exit.


 9: WKSPCE - //real// array of DIMENSION at least (N).

  Used as working space.


10: AA - //real// array of DIMENSION (IAA,s) where s.GE.N.

  On  exit,  unless  IFAIL = 1, AA contains the Crout factorisation with the
  unit diagonal of U understood.


11: IAA - INTEGER.

  On entry, IAA must specify the first dimension of array AA as declared  in
  the calling (sub)program (IAA.GE.N).

  Unchanged on exit.


12: BB - //real// array of DIMENSION (IBB,t) where t.GE.M.

  Used  as  working  space.  On  successful exit, BB contains the M residual
  vectors.


13: IBB - INTEGER.

  On entry, IBB must specify the first dimension of array BB as declared  in
  the calling (sub)program (IBB.GE.N).

  Unchanged on exit.


14: IFAIL - INTEGER.

  Before  entry, IFAIL must be assigned a value. For users not familiar with
  this parameter (described in Chapter P01) the recommended value is 0.

  Unless the routine detects an error (see next section), IFAIL  contains  0
  on exit.


D. Error Indicators and Warnings
================================

Errors detected by the routine:-

IFAIL = 1

  Failure in //F03AFF// , the matrix A is singular, possibly due to rounding
  errors.

IFAIL = 2

  Failure  in  //F04AHF//,  the  refinement  process  fails  to  improve the
  solution, i.e. the matrix A is ill-conditioned.
-------------------------------------------------------------------------------


There is also a bug in the program for the case that the smaller covariance
matrix is used in the computation of the EOFs (see manual, Appendix 3). This
happens if the number of time series is greater than the length of
the time series: if there are no gaps in the data this is done automatically
				 if there are gaps this is only done if you call the program
										with the option "-f".
The bug occurs only at the end of the program in the subroutine "STATS"
and you should not trust the output of the statistics package (Section 2.7
and pp. 37-38) too heavily in this case. All the other output is not 
influenced by the error and it doesn't happen at all if the number of time 
steps in your time series is greater than the number of "spatial" points 
(which will be true in most cases).


------------------------------------------------------------------------------


Adresses in case of problems:

         Hans von Storch or Reiner Schnur

         Max-Planck-Institut fuer Meteorologie
         Bundesstr. 55
         D-20146 Hamburg
         Germany
      
         Phone:    +49 40 41173-232 (Hans von Storch)
                               -264 (Reiner Schnur)

         Telefax:  +49 40 41173-298 (Max-Planck-Institut)

         E-Mail (internet) :  schnur@dkrz.d400.de (Reiner Schnur)
                              storch@dkrz.d400.de (Hans von Storch) 
